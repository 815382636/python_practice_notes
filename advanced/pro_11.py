#python对象的比较、拷贝


#比较操作符'=='表示比较对象间的值是否相等，而'is'表示比较对象的标识是否相等，即它们是否指向同一个内存地址。
# 比较操作符'is'效率优于'=='，因为'is'操作符无法被重载，执行'is'操作只是简单的获取对象的 ID，并进行比较；
# 而'=='操作符则会递归地遍历对象的所有值，并逐一比较。
# 浅拷贝中的元素，是原对象中子对象的引用，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用。
# 深度拷贝则会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。
# 另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其 ID，来提高效率并防止无限递归的发生。



a = 10
b = 10
# a == b
# True
id(a)
# 4427562448
id(b)
# 4427562448
a is b
# True
c =257
d =257
# c==d
# True
# c is d
# False

#出于对性能优化的考虑，Python 内部会对 -5 到 256 的整型维持一个数组，起到一个缓存的作用。
# 这样，每次你试图创建一个 -5 到 256 范围内的整型数字时，Python 都会从这个数组中返回相对应的引用，而不是重新开辟一块新的内存空间。
# 但是，如果整型数字超过了这个范围，比如上述例子中的 257，Python 则会为两个 257 开辟两块内存区域，
# 因此 c 和 d 的 ID 不一样，c is d就会返回 False 了。


#浅拷贝的几种形式
# 对于列表来说，因为列表是可变的数据类型，所以l1 ==l2,l1 is not l2，但是对于元组来说，因为元组是不可变的，浅拷贝完的元组全等
l1 =[1,2,3]

l2 =list(l1)
l2 =l1[:]
import copy
l2 =copy.copy(l1)

#深拷贝
#重新分配一块内存，与原对象完全分离
l2 =copy.deepcopy(l1)








