
# 二、字典和集合
#   相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。

di ={"name":"Liming","age":17}
print(di)
se ={1,2,3}
print(se)

# 访问使用get函数
print(di.get("name"))
print(di.get("a"))

#判断元素是否在集合中
print(1 in se)

#字典和集合的增加删除
di["location"] ="zibo"
di.pop("age")
print(di)

se.add(4)
se.remove(3)
print(se)

# 字典的升序排列
d_sorted_by_key =sorted(di.items(),key= lambda x:x[0])
print(d_sorted_by_key)
# 字典的降序排列 ，集合直接用sorted即可
d_sorted_by_key =sorted(di.items(),key= lambda x:x[1])
print(d_sorted_by_key)

# 由于集合是高度优化的哈希表，里面元素不能重复，并且其添加和查找操作只需 O(1) 的复杂度


#集合的排序,排序后变成列表
se_sort =sorted(se)
print(se_sort)

#不同于其他数据结构，字典和集合的内部结构都是一张哈希表。
#对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。
#而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。

#插入操作
#每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），
# 再和 mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index = hash(key) & mask。
# 如果哈希表中此位置是空的，那么这个元素就会被插入其中。
# 而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。
# 若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。
# 若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），
# 意思是两个元素的键不相等，但是哈希值相等。
# 这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。
# 值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。
# 当然，Python 内部对此进行了优化（这一点无需深入了解，你有兴趣可以查看源码，我就不再赘述），让这个步骤更加高效。

#查找操作
# 和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；
# 然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。
# 如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。


#删除操作
# 对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，
# 等到重新调整哈希表的大小时，再将其删除。
# 不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。
# 因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。
# 随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。
# 不过，这种情况下，表内所有的元素位置都会被重新排放。
# 虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。
# 所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。


















